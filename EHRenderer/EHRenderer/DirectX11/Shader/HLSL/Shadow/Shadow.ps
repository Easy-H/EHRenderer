Texture2D shaderTexture : register(t0);
Texture2D depthMapTexture : register(t1);

SamplerState SampleTypeClamp : register(s0);
SamplerState SampleTypeWrap : register(s1);

cbuffer LightBuffer {
	float bias;
	float3 padding;
}

struct PixelInputType {
	float4 position : SV_POSITION;
	float2 tex : TEXCOORD;
	float3 normal : NORMAL;
	float4 lightViewPosition : TEXCOORD1;
	float3 lightPos : TEXCOORD2;
};

float4 ShadowPixelShader(PixelInputType input) : SV_TARGET {
	
	float4 color;
	float2 projectTexCoord;
	float depthValue;
	float lightDepthValue;
	float lightIntensity;
	float4 textureColor;

	textureColor = shaderTexture.Sample(SampleTypeWrap, input.tex);

	if (textureColor.w < 0.2f) {
		discard;
	}

	color = float4(0.f, 0.f, 0.f, 1.f);

	projectTexCoord.x = input.lightViewPosition.x / input.lightViewPosition.w / 2.f + 0.5f;
	projectTexCoord.y = -input.lightViewPosition.y / input.lightViewPosition.w / 2.f + 0.5f;

	if ((saturate(projectTexCoord.x) == projectTexCoord.x) && (saturate(projectTexCoord.y) == projectTexCoord.y)) {
		depthValue = depthMapTexture.Sample(SampleTypeClamp, projectTexCoord).r;

		lightDepthValue = input.lightViewPosition.z / input.lightViewPosition.w;
		lightDepthValue = lightDepthValue - bias;

		if (lightDepthValue < depthValue) {
			color = float4(1.f, 1.f, 1.f, 1.f);
		}
	}

	return color;

}